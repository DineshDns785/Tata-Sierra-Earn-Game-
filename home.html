<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Tata Sierra Earn â€“ Game</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;}
    body{
      background:#000;
      overflow:hidden;
      font-family:system-ui, sans-serif;
    }
    #gameCanvas{
      display:block;
      margin:0 auto;
      background:#111;
      touch-action:none;
    }
    #ui{
      position:fixed;
      top:8px;left:8px;right:8px;
      color:#fff;
      font-size:14px;
      display:flex;
      justify-content:space-between;
      text-shadow:0 0 4px #000;
      pointer-events:none;
    }
    #buttons{
      position:fixed;
      bottom:20px;
      left:0;right:0;
      display:flex;
      justify-content:space-between;
      padding:0 40px;
    }
.btn{
  width:80px;height:80px;
  border-radius:50%;
  border:2px solid #0f0;
  background-size:cover;
  background-position:center;
  font-size:0; /* text hide */
}
#leftBtn{ background-image: url('left-btn.png'); }
#rightBtn{ background-image: url('right-btn.png'); }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="360" height="640"></canvas>

  <div id="ui">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
    <div>Coins: <span id="coins">0</span></div>
  </div>

  <div id="buttons">
    <div id="leftBtn"  class="btn">âŸµ</div>
    <div id="rightBtn" class="btn">âŸ¶</div>
  </div>

  <!-- GAME OVER POPUP -->
  <div id="gameOver"
       style="position:fixed; inset:0;
              background:rgba(0,0,0,0.85);
              display:none;
              flex-direction:column;
              align-items:center;
              justify-content:center;
              color:#fff; z-index:20;">

    <!-- Adsterra iframe -->
    <script>
      atOptions = {
        'key' : 'b6e60c2319eb7e7338f440cbb61abf82',
        'format' : 'iframe',
        'height' : 250,
        'width' : 300,
        'params' : {}
      };
    </script>
    <script src="https://www.highperformanceformat.com/b6e60c2319eb7e7338f440cbb61abf82/invoke.js"></script>

    <h2 style="margin-bottom:8px;">ðŸ’¥ Game Over</h2>
    <p style="font-size:13px;margin-bottom:20px;text-align:center;">
      Your car collided with a vehicle!
    </p>
    <div style="display:flex;gap:8px;margin-bottom:10px;">
      <button onclick="location.href='index.html'"
              style="padding:9px 14px;border:none;
                     border-radius:18px;
                     background:#3b82f6;
                     color:#fff;
                     box-shadow:0 0 12px rgba(59,130,246,0.6);">
        Home
      </button>
      <button id="playAgainBtn"
              style="padding:9px 16px;border:none;
                     border-radius:18px;
                     background:#00ff88;
                     color:#000;font-weight:600;">
        Play Now
      </button>
      <button onclick="location.href='withdraw.html'"
              style="padding:9px 14px;border:none;
                     border-radius:18px;
                     background:#ffb300;color:#000;">
        Withdraw
      </button>
    </div>
  </div>

  <script>
    const LANES = 4;
    const ROAD_WIDTH = 260;
    const CAR_W = 60, CAR_H = 110;
    const ENEMY_SPEED_START = 6;
    const ENEMY_SPEED_MAX   = 10;

    const canvas = document.getElementById('gameCanvas');
    const ctx     = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const bestEl  = document.getElementById('best');
    const coinsEl = document.getElementById('coins');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn= document.getElementById('rightBtn');

    const gameOverPanel = document.getElementById('gameOver');
    const playAgainBtn  = document.getElementById('playAgainBtn');

    const playerImg = new Image();
    playerImg.src = 'player.png';

    const enemyImgs = ['1enemy.png','2enemy.png','3enemy.png'].map(src=>{
      const img = new Image();
      img.src = src;
      return img;
    });

    const roadImg = new Image();
    roadImg.src  = 'road.png';

    const POLE_COLOR  = '#facc15';
    const TREE_TRUNK  = '#78350f';
    const TREE_LEAF   = '#22c55e';

    let laneX = [];
    let playerLane = 1;
    let playerY;

    let enemies = [];
    let laneOccupied = [false, false, false, false];
    let speed  = ENEMY_SPEED_START;
    let score = 0;
    let best  = parseInt(localStorage.getItem('bestScore4Lane') || '0', 10);
    bestEl.textContent = best;

    let coins = parseInt(localStorage.getItem('coins') || '0', 10);
    let totalEarned = parseInt(localStorage.getItem('totalEarned') || '0', 10);
    coinsEl.textContent = coins;

    let running = true;
    let roadOffset = 0;
    let startTime = Date.now();

    function initLanes(){
      const centerX = canvas.width/2;
      const startX = centerX - ROAD_WIDTH/2;
      const laneWidth = ROAD_WIDTH / LANES;
      laneX = [];
      for(let i=0;i<LANES;i++){
        laneX.push(startX + laneWidth*i + laneWidth/2 - CAR_W/2);
      }
      playerLane = 1;
      playerY = canvas.height - CAR_H - 40;
    }

    function spawnEnemy(){
      const freeLanes = [];
      for (let i = 0; i < LANES; i++) {
        if (!laneOccupied[i]) freeLanes.push(i);
      }
      if (freeLanes.length === 0 || Math.random() > 0.02) return; // sirf 2% chance spawn

      const lane = freeLanes[Math.floor(Math.random() * freeLanes.length)];

      enemies.push({
        lane: lane,
        x: laneX[lane],
        y: -CAR_H - 20,
        vy: speed, // fixed normal speed
        img: enemyImgs[Math.floor(Math.random()*enemyImgs.length)]
      });

      laneOccupied[lane] = true;
    }

    function resetGame(){
      enemies = [];
      laneOccupied = [false,false,false,false];
      speed   = ENEMY_SPEED_START;
      score   = 0;
      running = true;
      gameOverPanel.style.display = 'none';
      startTime = Date.now();
    }

    function moveLeft(){ if(playerLane>0) playerLane--; }
    function moveRight(){ if(playerLane<LANES-1) playerLane++; }

    leftBtn.addEventListener('touchstart',e=>{ e.preventDefault(); moveLeft(); });
    rightBtn.addEventListener('touchstart',e=>{ e.preventDefault(); moveRight(); });

    window.addEventListener('keydown',e=>{
      if(e.key==='ArrowLeft' || e.key==='a') moveLeft();
      if(e.key==='ArrowRight'|| e.key==='d') moveRight();
      if(!running && (e.key==='Enter' || e.key===' ')) resetGame();
    });

    playAgainBtn.onclick = () => resetGame();

    function rectHit(x1,y1,w1,h1,x2,y2,w2,h2){
      const padding = 10;
      return (
        x1 + padding < x2 + w2 - padding &&
        x1 + w1 - padding > x2 + padding &&
        y1 + padding < y2 + h2 - padding &&
        y1 + h1 - padding > y2 + padding
      );
    }

    function update(){
      if (!running) return;

      // 1 minute (60 sec) ke baad game hard
      const elapsedSec = (Date.now() - startTime) / 1000;
      if (elapsedSec > 60 && speed < ENEMY_SPEED_MAX) {
        speed += 0.15; // gradually hard
      }

      // move enemies
      enemies.forEach(e => { e.vy = speed; e.y += e.vy; });

      enemies = enemies.filter(e => {
        if (e.y >= canvas.height + CAR_H) {
          laneOccupied[e.lane] = false;
          return false;
        }
        return true;
      });

      // controlled spawn - not ek saath
      if (enemies.length < 3 && Math.random() < 2.115) {
        spawnEnemy();
      }

      score += 1;

      if (score % 150 === 0) {
        coins += 1;
        totalEarned += 1;
        localStorage.setItem('coins', coins.toString());
        localStorage.setItem('totalEarned', totalEarned.toString());
      }

      const px = laneX[playerLane];
      enemies.forEach(e => {
        if (rectHit(px, playerY, CAR_W, CAR_H,
                    e.x, e.y, CAR_W, CAR_H)) {
          running = false;
          if (score > best) {
            best = score;
            localStorage.setItem('bestScore4Lane', best.toString());
          }
          gameOverPanel.style.display = 'flex';
        }
      });
    }

    // Road + roadside lights + trees (2D road)
    function drawRoad(){
      const cx = canvas.width/2;
      const startX = cx - ROAD_WIDTH/2;

      if (roadImg.complete && roadImg.naturalWidth>0){
        const pattern = ctx.createPattern(roadImg,'repeat-y');
        ctx.save();
        ctx.translate(0, roadOffset%roadImg.height);
        ctx.fillStyle = pattern;
        ctx.fillRect(startX-10,-roadImg.height,
                     ROAD_WIDTH+20,
                     canvas.height+roadImg.height*2);
        ctx.restore();
      } else {
        ctx.fillStyle = '#222';
        ctx.fillRect(startX,0,ROAD_WIDTH,canvas.height);

        ctx.strokeStyle='#f90';
        ctx.lineWidth=4;
        const laneWidth = ROAD_WIDTH / LANES;
        for(let i=1;i<LANES;i++){
          const x = startX + laneWidth*i;
          ctx.setLineDash([20,20]);
          ctx.beginPath();
          ctx.moveTo(x, (roadOffset%40)-40);
          ctx.lineTo(x, canvas.height+40);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      const segment = 80;
      const offsetY = roadOffset % segment;

      for(let y = -segment; y < canvas.height + segment; y += segment){
        const drawY = y + offsetY;

        const leftXPole  = startX - 25;
        const leftXTree  = startX - 45;
        const rightXPole = startX + ROAD_WIDTH + 10;
        const rightXTree = startX + ROAD_WIDTH + 30;

        ctx.strokeStyle = POLE_COLOR;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(leftXPole,  drawY + 10);
        ctx.lineTo(leftXPole,  drawY - 25);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(rightXPole, drawY + 10);
        ctx.lineTo(rightXPole, drawY - 25);
        ctx.stroke();

        ctx.fillStyle = POLE_COLOR;
        ctx.beginPath();
        ctx.arc(leftXPole,  drawY - 27, 4, 0, Math.PI*2);
        ctx.arc(rightXPole, drawY - 27, 4, 0, Math.PI*2);
        ctx.fill();

        let grad = ctx.createRadialGradient(
          leftXPole, drawY - 27, 0,
          leftXPole, drawY - 27, 20
        );
        grad.addColorStop(0, 'rgba(250,204,21,0.4)');
        grad.addColorStop(1, 'rgba(250,204,21,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(leftXPole, drawY - 27, 20, 0, Math.PI*2);
        ctx.fill();

        grad = ctx.createRadialGradient(
          rightXPole, drawY - 27, 0,
          rightXPole, drawY - 27, 20
        );
        grad.addColorStop(0, 'rgba(250,204,21,0.4)');
        grad.addColorStop(1, 'rgba(250,204,21,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(rightXPole, drawY - 27, 20, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = TREE_TRUNK;
        ctx.fillRect(leftXTree-2,  drawY, 4, 18);
        ctx.fillRect(rightXTree-2, drawY, 4, 18);

        ctx.fillStyle = TREE_LEAF;
        ctx.beginPath();
        ctx.moveTo(leftXTree, drawY - 4);
        ctx.lineTo(leftXTree-10, drawY + 10);
        ctx.lineTo(leftXTree+10, drawY + 10);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(rightXTree, drawY - 4);
        ctx.lineTo(rightXTree-10, drawY + 10);
        ctx.lineTo(rightXTree+10, drawY + 10);
        ctx.closePath();
        ctx.fill();
      }

      roadOffset += speed*0.5;
    }

    function render(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawRoad();

      const px = laneX[playerLane];
      if(playerImg.complete && playerImg.naturalWidth>0){
        ctx.drawImage(playerImg,px,playerY,CAR_W,CAR_H);
      } else {
        ctx.fillStyle='#0f0';
        ctx.fillRect(px,playerY,CAR_W,CAR_H);
      }

      enemies.forEach(e=>{
        if(e.img.complete && e.img.naturalWidth>0){
          ctx.drawImage(e.img, e.x, e.y, CAR_W, CAR_H);
        } else {
          ctx.fillStyle='#f00';
          ctx.fillRect(e.x,e.y,CAR_W,CAR_H);
        }
      });

      scoreEl.textContent = score;
      bestEl.textContent  = best;
      coinsEl.textContent = coins;

      requestAnimationFrame(loop);
    }

    function loop(){
      update();
      render();
    }

    initLanes();
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>